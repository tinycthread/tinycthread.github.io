<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.6"/>
<title>TinyCThread: tinycthread.h File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">TinyCThread
   &#160;<span id="projectnumber">1.1</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.6 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="files.html"><span>File&#160;List</span></a></li>
      <li><a href="globals.html"><span>Globals</span></a></li>
    </ul>
  </div>
<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="dir_b2f33c71d4aa5e7af42a1ca61ff5af1b.html">source</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#define-members">Macros</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">tinycthread.h File Reference</div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><code>#include &lt;time.h&gt;</code><br/>
<code>#include &lt;pthread.h&gt;</code><br/>
</div>
<p><a href="tinycthread_8h_source.html">Go to the source code of this file.</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:a953f67c466c6b20cb8b45bae7322a4bb"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="tinycthread_8h.html#a953f67c466c6b20cb8b45bae7322a4bb">TINYCTHREAD_VERSION_MAJOR</a>&#160;&#160;&#160;1</td></tr>
<tr class="memdesc:a953f67c466c6b20cb8b45bae7322a4bb"><td class="mdescLeft">&#160;</td><td class="mdescRight">TinyCThread version (major number).  <a href="#a953f67c466c6b20cb8b45bae7322a4bb">More...</a><br/></td></tr>
<tr class="separator:a953f67c466c6b20cb8b45bae7322a4bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4b0bb3afcfbecfad0a260c56a2600485"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="tinycthread_8h.html#a4b0bb3afcfbecfad0a260c56a2600485">TINYCTHREAD_VERSION_MINOR</a>&#160;&#160;&#160;2</td></tr>
<tr class="memdesc:a4b0bb3afcfbecfad0a260c56a2600485"><td class="mdescLeft">&#160;</td><td class="mdescRight">TinyCThread version (minor number).  <a href="#a4b0bb3afcfbecfad0a260c56a2600485">More...</a><br/></td></tr>
<tr class="separator:a4b0bb3afcfbecfad0a260c56a2600485"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a68b525cf21cb295d457f87c45ca45604"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="tinycthread_8h.html#a68b525cf21cb295d457f87c45ca45604">TINYCTHREAD_VERSION</a>&#160;&#160;&#160;(<a class="el" href="tinycthread_8h.html#a953f67c466c6b20cb8b45bae7322a4bb">TINYCTHREAD_VERSION_MAJOR</a> * 100 + <a class="el" href="tinycthread_8h.html#a4b0bb3afcfbecfad0a260c56a2600485">TINYCTHREAD_VERSION_MINOR</a>)</td></tr>
<tr class="memdesc:a68b525cf21cb295d457f87c45ca45604"><td class="mdescLeft">&#160;</td><td class="mdescRight">TinyCThread version (full version).  <a href="#a68b525cf21cb295d457f87c45ca45604">More...</a><br/></td></tr>
<tr class="separator:a68b525cf21cb295d457f87c45ca45604"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6ee13d5bcebab292dbc98e06c6cf9fe7"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="tinycthread_8h.html#a6ee13d5bcebab292dbc98e06c6cf9fe7">_Thread_local</a></td></tr>
<tr class="memdesc:a6ee13d5bcebab292dbc98e06c6cf9fe7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Thread local storage keyword.  <a href="#a6ee13d5bcebab292dbc98e06c6cf9fe7">More...</a><br/></td></tr>
<tr class="separator:a6ee13d5bcebab292dbc98e06c6cf9fe7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0944e70c2ce4eed616f7bcfd604fba96"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a0944e70c2ce4eed616f7bcfd604fba96"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="tinycthread_8h.html#a0944e70c2ce4eed616f7bcfd604fba96">thrd_error</a>&#160;&#160;&#160;0</td></tr>
<tr class="memdesc:a0944e70c2ce4eed616f7bcfd604fba96"><td class="mdescLeft">&#160;</td><td class="mdescRight">The requested operation failed. <br/></td></tr>
<tr class="separator:a0944e70c2ce4eed616f7bcfd604fba96"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6f15c94421801f7f6a4338653b9017dc"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a6f15c94421801f7f6a4338653b9017dc"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="tinycthread_8h.html#a6f15c94421801f7f6a4338653b9017dc">thrd_success</a>&#160;&#160;&#160;1</td></tr>
<tr class="memdesc:a6f15c94421801f7f6a4338653b9017dc"><td class="mdescLeft">&#160;</td><td class="mdescRight">The requested operation succeeded. <br/></td></tr>
<tr class="separator:a6f15c94421801f7f6a4338653b9017dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a110a67f47dae673b72b3c8f462d29384"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a110a67f47dae673b72b3c8f462d29384"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="tinycthread_8h.html#a110a67f47dae673b72b3c8f462d29384">thrd_timedout</a>&#160;&#160;&#160;2</td></tr>
<tr class="memdesc:a110a67f47dae673b72b3c8f462d29384"><td class="mdescLeft">&#160;</td><td class="mdescRight">The time specified in the call was reached without acquiring the requested resource. <br/></td></tr>
<tr class="separator:a110a67f47dae673b72b3c8f462d29384"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3c563aa25920a041d83d4019b113ab5d"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a3c563aa25920a041d83d4019b113ab5d"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="tinycthread_8h.html#a3c563aa25920a041d83d4019b113ab5d">thrd_busy</a>&#160;&#160;&#160;3</td></tr>
<tr class="memdesc:a3c563aa25920a041d83d4019b113ab5d"><td class="mdescLeft">&#160;</td><td class="mdescRight">The requested operation failed because a tesource requested by a test and return function is already in use. <br/></td></tr>
<tr class="separator:a3c563aa25920a041d83d4019b113ab5d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad6010b6ba8c0508cef692f066b09e2ef"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad6010b6ba8c0508cef692f066b09e2ef"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="tinycthread_8h.html#ad6010b6ba8c0508cef692f066b09e2ef">thrd_nomem</a>&#160;&#160;&#160;4</td></tr>
<tr class="memdesc:ad6010b6ba8c0508cef692f066b09e2ef"><td class="mdescLeft">&#160;</td><td class="mdescRight">The requested operation failed because it was unable to allocate memory. <br/></td></tr>
<tr class="separator:ad6010b6ba8c0508cef692f066b09e2ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a59cf64c83a8331359b1ee9463f77238e"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="tinycthread_8h.html#a59cf64c83a8331359b1ee9463f77238e">call_once</a>(flag, func)&#160;&#160;&#160;pthread_once(flag,func)</td></tr>
<tr class="memdesc:a59cf64c83a8331359b1ee9463f77238e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Invoke a callback exactly once.  <a href="#a59cf64c83a8331359b1ee9463f77238e">More...</a><br/></td></tr>
<tr class="separator:a59cf64c83a8331359b1ee9463f77238e"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:a7d8f0a9d1b1848b938e49dc7bd97ba07"><td class="memItemLeft" align="right" valign="top">typedef int(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="tinycthread_8h.html#a7d8f0a9d1b1848b938e49dc7bd97ba07">thrd_start_t</a> )(void *arg)</td></tr>
<tr class="memdesc:a7d8f0a9d1b1848b938e49dc7bd97ba07"><td class="mdescLeft">&#160;</td><td class="mdescRight">Thread start function.  <a href="#a7d8f0a9d1b1848b938e49dc7bd97ba07">More...</a><br/></td></tr>
<tr class="separator:a7d8f0a9d1b1848b938e49dc7bd97ba07"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ade88b5efc6801e759cb4be71326a2e2a"><td class="memItemLeft" align="right" valign="top">typedef void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="tinycthread_8h.html#ade88b5efc6801e759cb4be71326a2e2a">tss_dtor_t</a> )(void *val)</td></tr>
<tr class="memdesc:ade88b5efc6801e759cb4be71326a2e2a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destructor function for a thread-specific storage.  <a href="#ade88b5efc6801e759cb4be71326a2e2a">More...</a><br/></td></tr>
<tr class="separator:ade88b5efc6801e759cb4be71326a2e2a"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a89200caf0dc25fcc97df171d0034bff2"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="tinycthread_8h.html#a89200caf0dc25fcc97df171d0034bff2">mtx_init</a> (mtx_t *mtx, int type)</td></tr>
<tr class="memdesc:a89200caf0dc25fcc97df171d0034bff2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a mutex object.  <a href="#a89200caf0dc25fcc97df171d0034bff2">More...</a><br/></td></tr>
<tr class="separator:a89200caf0dc25fcc97df171d0034bff2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae8b3732298d1d316db6438b4c561c0dd"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="tinycthread_8h.html#ae8b3732298d1d316db6438b4c561c0dd">mtx_destroy</a> (mtx_t *mtx)</td></tr>
<tr class="memdesc:ae8b3732298d1d316db6438b4c561c0dd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Release any resources used by the given mutex.  <a href="#ae8b3732298d1d316db6438b4c561c0dd">More...</a><br/></td></tr>
<tr class="separator:ae8b3732298d1d316db6438b4c561c0dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8945984db67db8ee774872da64d0e424"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="tinycthread_8h.html#a8945984db67db8ee774872da64d0e424">mtx_lock</a> (mtx_t *mtx)</td></tr>
<tr class="memdesc:a8945984db67db8ee774872da64d0e424"><td class="mdescLeft">&#160;</td><td class="mdescRight">Lock the given mutex.  <a href="#a8945984db67db8ee774872da64d0e424">More...</a><br/></td></tr>
<tr class="separator:a8945984db67db8ee774872da64d0e424"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a98f9757dde089254735199ac738ff65f"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a98f9757dde089254735199ac738ff65f"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="tinycthread_8h.html#a98f9757dde089254735199ac738ff65f">mtx_timedlock</a> (mtx_t *mtx, const struct timespec *ts)</td></tr>
<tr class="memdesc:a98f9757dde089254735199ac738ff65f"><td class="mdescLeft">&#160;</td><td class="mdescRight">NOT YET IMPLEMENTED. <br/></td></tr>
<tr class="separator:a98f9757dde089254735199ac738ff65f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac577690ddd48f5a1fdf3dc97881a2199"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="tinycthread_8h.html#ac577690ddd48f5a1fdf3dc97881a2199">mtx_trylock</a> (mtx_t *mtx)</td></tr>
<tr class="memdesc:ac577690ddd48f5a1fdf3dc97881a2199"><td class="mdescLeft">&#160;</td><td class="mdescRight">Try to lock the given mutex.  <a href="#ac577690ddd48f5a1fdf3dc97881a2199">More...</a><br/></td></tr>
<tr class="separator:ac577690ddd48f5a1fdf3dc97881a2199"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae2fb1d2854461fa583017cc9b0bc6cca"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="tinycthread_8h.html#ae2fb1d2854461fa583017cc9b0bc6cca">mtx_unlock</a> (mtx_t *mtx)</td></tr>
<tr class="memdesc:ae2fb1d2854461fa583017cc9b0bc6cca"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unlock the given mutex.  <a href="#ae2fb1d2854461fa583017cc9b0bc6cca">More...</a><br/></td></tr>
<tr class="separator:ae2fb1d2854461fa583017cc9b0bc6cca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a146f4cd218c2a2f770be14c1dee26d08"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="tinycthread_8h.html#a146f4cd218c2a2f770be14c1dee26d08">cnd_init</a> (cnd_t *cond)</td></tr>
<tr class="memdesc:a146f4cd218c2a2f770be14c1dee26d08"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a condition variable object.  <a href="#a146f4cd218c2a2f770be14c1dee26d08">More...</a><br/></td></tr>
<tr class="separator:a146f4cd218c2a2f770be14c1dee26d08"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa925921fa9edc189f474ae10a23bcfd3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="tinycthread_8h.html#aa925921fa9edc189f474ae10a23bcfd3">cnd_destroy</a> (cnd_t *cond)</td></tr>
<tr class="memdesc:aa925921fa9edc189f474ae10a23bcfd3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Release any resources used by the given condition variable.  <a href="#aa925921fa9edc189f474ae10a23bcfd3">More...</a><br/></td></tr>
<tr class="separator:aa925921fa9edc189f474ae10a23bcfd3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af76e066715b1190d38a69da1c511e30f"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="tinycthread_8h.html#af76e066715b1190d38a69da1c511e30f">cnd_signal</a> (cnd_t *cond)</td></tr>
<tr class="memdesc:af76e066715b1190d38a69da1c511e30f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Signal a condition variable.  <a href="#af76e066715b1190d38a69da1c511e30f">More...</a><br/></td></tr>
<tr class="separator:af76e066715b1190d38a69da1c511e30f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a66228b340509733bdf529b93bca8df14"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="tinycthread_8h.html#a66228b340509733bdf529b93bca8df14">cnd_broadcast</a> (cnd_t *cond)</td></tr>
<tr class="memdesc:a66228b340509733bdf529b93bca8df14"><td class="mdescLeft">&#160;</td><td class="mdescRight">Broadcast a condition variable.  <a href="#a66228b340509733bdf529b93bca8df14">More...</a><br/></td></tr>
<tr class="separator:a66228b340509733bdf529b93bca8df14"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac4dfb82fc3d92bb688cb07308af6a659"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="tinycthread_8h.html#ac4dfb82fc3d92bb688cb07308af6a659">cnd_wait</a> (cnd_t *cond, mtx_t *mtx)</td></tr>
<tr class="memdesc:ac4dfb82fc3d92bb688cb07308af6a659"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wait for a condition variable to become signaled.  <a href="#ac4dfb82fc3d92bb688cb07308af6a659">More...</a><br/></td></tr>
<tr class="separator:ac4dfb82fc3d92bb688cb07308af6a659"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2bdc352d949424855c957b0d1916d443"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="tinycthread_8h.html#a2bdc352d949424855c957b0d1916d443">cnd_timedwait</a> (cnd_t *cond, mtx_t *mtx, const struct timespec *ts)</td></tr>
<tr class="memdesc:a2bdc352d949424855c957b0d1916d443"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wait for a condition variable to become signaled.  <a href="#a2bdc352d949424855c957b0d1916d443">More...</a><br/></td></tr>
<tr class="separator:a2bdc352d949424855c957b0d1916d443"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1a52b6cd2d15cc6c4741d5124f85d183"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="tinycthread_8h.html#a1a52b6cd2d15cc6c4741d5124f85d183">thrd_create</a> (thrd_t *thr, <a class="el" href="tinycthread_8h.html#a7d8f0a9d1b1848b938e49dc7bd97ba07">thrd_start_t</a> func, void *arg)</td></tr>
<tr class="memdesc:a1a52b6cd2d15cc6c4741d5124f85d183"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a new thread.  <a href="#a1a52b6cd2d15cc6c4741d5124f85d183">More...</a><br/></td></tr>
<tr class="separator:a1a52b6cd2d15cc6c4741d5124f85d183"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab67b6f182a848d979155d03598325fa7"><td class="memItemLeft" align="right" valign="top">thrd_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="tinycthread_8h.html#ab67b6f182a848d979155d03598325fa7">thrd_current</a> (void)</td></tr>
<tr class="memdesc:ab67b6f182a848d979155d03598325fa7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Identify the calling thread.  <a href="#ab67b6f182a848d979155d03598325fa7">More...</a><br/></td></tr>
<tr class="separator:ab67b6f182a848d979155d03598325fa7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad5380997f9e32a31f802bdd9cb266902"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="tinycthread_8h.html#ad5380997f9e32a31f802bdd9cb266902">thrd_detach</a> (thrd_t thr)</td></tr>
<tr class="memdesc:ad5380997f9e32a31f802bdd9cb266902"><td class="mdescLeft">&#160;</td><td class="mdescRight">Dispose of any resources allocated to the thread when that thread exits.  <a href="#ad5380997f9e32a31f802bdd9cb266902">More...</a><br/></td></tr>
<tr class="separator:ad5380997f9e32a31f802bdd9cb266902"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a153e65a389814ce51ad07791e42b2118"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="tinycthread_8h.html#a153e65a389814ce51ad07791e42b2118">thrd_equal</a> (thrd_t thr0, thrd_t thr1)</td></tr>
<tr class="memdesc:a153e65a389814ce51ad07791e42b2118"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compare two thread identifiers.  <a href="#a153e65a389814ce51ad07791e42b2118">More...</a><br/></td></tr>
<tr class="separator:a153e65a389814ce51ad07791e42b2118"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a841a332cdf32140ae6e44a3bb0bcdcd0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="tinycthread_8h.html#a841a332cdf32140ae6e44a3bb0bcdcd0">thrd_exit</a> (int res) TTHREAD_NORETURN</td></tr>
<tr class="memdesc:a841a332cdf32140ae6e44a3bb0bcdcd0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Terminate execution of the calling thread.  <a href="#a841a332cdf32140ae6e44a3bb0bcdcd0">More...</a><br/></td></tr>
<tr class="separator:a841a332cdf32140ae6e44a3bb0bcdcd0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa2e83a544f49f74cf217a69a882b5d80"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="tinycthread_8h.html#aa2e83a544f49f74cf217a69a882b5d80">thrd_join</a> (thrd_t thr, int *res)</td></tr>
<tr class="memdesc:aa2e83a544f49f74cf217a69a882b5d80"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wait for a thread to terminate.  <a href="#aa2e83a544f49f74cf217a69a882b5d80">More...</a><br/></td></tr>
<tr class="separator:aa2e83a544f49f74cf217a69a882b5d80"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a77f5f79db415e2363470a8570250f785"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="tinycthread_8h.html#a77f5f79db415e2363470a8570250f785">thrd_sleep</a> (const struct timespec *duration, struct timespec *remaining)</td></tr>
<tr class="memdesc:a77f5f79db415e2363470a8570250f785"><td class="mdescLeft">&#160;</td><td class="mdescRight">Put the calling thread to sleep.  <a href="#a77f5f79db415e2363470a8570250f785">More...</a><br/></td></tr>
<tr class="separator:a77f5f79db415e2363470a8570250f785"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acbfb78346e6b76b23da1d2d8df03549a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="tinycthread_8h.html#acbfb78346e6b76b23da1d2d8df03549a">thrd_yield</a> (void)</td></tr>
<tr class="memdesc:acbfb78346e6b76b23da1d2d8df03549a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Yield execution to another thread.  <a href="#acbfb78346e6b76b23da1d2d8df03549a">More...</a><br/></td></tr>
<tr class="separator:acbfb78346e6b76b23da1d2d8df03549a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a286fe7927e9af276a9cfdbc8b9eb08ad"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="tinycthread_8h.html#a286fe7927e9af276a9cfdbc8b9eb08ad">tss_create</a> (tss_t *key, <a class="el" href="tinycthread_8h.html#ade88b5efc6801e759cb4be71326a2e2a">tss_dtor_t</a> dtor)</td></tr>
<tr class="memdesc:a286fe7927e9af276a9cfdbc8b9eb08ad"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a thread-specific storage.  <a href="#a286fe7927e9af276a9cfdbc8b9eb08ad">More...</a><br/></td></tr>
<tr class="separator:a286fe7927e9af276a9cfdbc8b9eb08ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aecebbc66b206171d9381ba94528c6cb7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="tinycthread_8h.html#aecebbc66b206171d9381ba94528c6cb7">tss_delete</a> (tss_t key)</td></tr>
<tr class="memdesc:aecebbc66b206171d9381ba94528c6cb7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Delete a thread-specific storage.  <a href="#aecebbc66b206171d9381ba94528c6cb7">More...</a><br/></td></tr>
<tr class="separator:aecebbc66b206171d9381ba94528c6cb7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a183e71f731ed566a1d14b056606806f8"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="tinycthread_8h.html#a183e71f731ed566a1d14b056606806f8">tss_get</a> (tss_t key)</td></tr>
<tr class="memdesc:a183e71f731ed566a1d14b056606806f8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the value for a thread-specific storage.  <a href="#a183e71f731ed566a1d14b056606806f8">More...</a><br/></td></tr>
<tr class="separator:a183e71f731ed566a1d14b056606806f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a608e01c49b84a5ad4f085a9aedc6a680"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="tinycthread_8h.html#a608e01c49b84a5ad4f085a9aedc6a680">tss_set</a> (tss_t key, void *val)</td></tr>
<tr class="memdesc:a608e01c49b84a5ad4f085a9aedc6a680"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the value for a thread-specific storage.  <a href="#a608e01c49b84a5ad4f085a9aedc6a680">More...</a><br/></td></tr>
<tr class="separator:a608e01c49b84a5ad4f085a9aedc6a680"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Macro Definition Documentation</h2>
<a class="anchor" id="a6ee13d5bcebab292dbc98e06c6cf9fe7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define _Thread_local</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Thread local storage keyword. </p>
<p>A variable that is declared with the <code>_Thread_local</code> keyword makes the value of the variable local to each thread (known as thread-local storage, or TLS). Example usage: </p>
<div class="fragment"><div class="line"><span class="comment">// This variable is local to each thread.</span></div>
<div class="line"><a class="code" href="tinycthread_8h.html#a6ee13d5bcebab292dbc98e06c6cf9fe7">_Thread_local</a> <span class="keywordtype">int</span> variable;</div>
</div><!-- fragment --> <dl class="section note"><dt>Note</dt><dd>The <code>_Thread_local</code> keyword is a macro that maps to the corresponding compiler directive (e.g. <code>__declspec(thread)</code>). </dd>
<dd>
This directive is currently not supported on Mac OS X (it will give a compiler error), since compile-time TLS is not supported in the Mac OS X executable format. Also, some older versions of MinGW (before GCC 4.x) do not support this directive, nor does the Tiny C Compiler. </dd></dl>

</div>
</div>
<a class="anchor" id="a59cf64c83a8331359b1ee9463f77238e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define call_once</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">flag, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">func&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td>&#160;&#160;&#160;pthread_once(flag,func)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Invoke a callback exactly once. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">flag</td><td>Flag used to ensure the callback is invoked exactly once. </td></tr>
    <tr><td class="paramname">func</td><td>Callback to invoke. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a68b525cf21cb295d457f87c45ca45604"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define TINYCTHREAD_VERSION&#160;&#160;&#160;(<a class="el" href="tinycthread_8h.html#a953f67c466c6b20cb8b45bae7322a4bb">TINYCTHREAD_VERSION_MAJOR</a> * 100 + <a class="el" href="tinycthread_8h.html#a4b0bb3afcfbecfad0a260c56a2600485">TINYCTHREAD_VERSION_MINOR</a>)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>TinyCThread version (full version). </p>

</div>
</div>
<a class="anchor" id="a953f67c466c6b20cb8b45bae7322a4bb"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define TINYCTHREAD_VERSION_MAJOR&#160;&#160;&#160;1</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>TinyCThread version (major number). </p>

</div>
</div>
<a class="anchor" id="a4b0bb3afcfbecfad0a260c56a2600485"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define TINYCTHREAD_VERSION_MINOR&#160;&#160;&#160;2</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>TinyCThread version (minor number). </p>

</div>
</div>
<h2 class="groupheader">Typedef Documentation</h2>
<a class="anchor" id="a7d8f0a9d1b1848b938e49dc7bd97ba07"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef int(* thrd_start_t)(void *arg)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Thread start function. </p>
<p>Any thread that is started with the <a class="el" href="tinycthread_8h.html#a1a52b6cd2d15cc6c4741d5124f85d183">thrd_create()</a> function must be started through a function of this type. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">arg</td><td>The thread argument (the <code>arg</code> argument of the corresponding <a class="el" href="tinycthread_8h.html#a1a52b6cd2d15cc6c4741d5124f85d183">thrd_create()</a> call). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The thread return value, which can be obtained by another thread by using the <a class="el" href="tinycthread_8h.html#aa2e83a544f49f74cf217a69a882b5d80">thrd_join()</a> function. </dd></dl>

</div>
</div>
<a class="anchor" id="ade88b5efc6801e759cb4be71326a2e2a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef void(* tss_dtor_t)(void *val)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Destructor function for a thread-specific storage. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">val</td><td>The value of the destructed thread-specific storage. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a class="anchor" id="a66228b340509733bdf529b93bca8df14"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int cnd_broadcast </td>
          <td>(</td>
          <td class="paramtype">cnd_t *&#160;</td>
          <td class="paramname"><em>cond</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Broadcast a condition variable. </p>
<p>Unblocks all of the threads that are blocked on the given condition variable at the time of the call. If no threads are blocked on the condition variable at the time of the call, the function does nothing and return success. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cond</td><td>A condition variable object. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="tinycthread_8h.html#a6f15c94421801f7f6a4338653b9017dc">thrd_success</a> on success, or <a class="el" href="tinycthread_8h.html#a0944e70c2ce4eed616f7bcfd604fba96">thrd_error</a> if the request could not be honored. </dd></dl>

</div>
</div>
<a class="anchor" id="aa925921fa9edc189f474ae10a23bcfd3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cnd_destroy </td>
          <td>(</td>
          <td class="paramtype">cnd_t *&#160;</td>
          <td class="paramname"><em>cond</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Release any resources used by the given condition variable. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cond</td><td>A condition variable object. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a146f4cd218c2a2f770be14c1dee26d08"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int cnd_init </td>
          <td>(</td>
          <td class="paramtype">cnd_t *&#160;</td>
          <td class="paramname"><em>cond</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a condition variable object. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cond</td><td>A condition variable object. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="tinycthread_8h.html#a6f15c94421801f7f6a4338653b9017dc">thrd_success</a> on success, or <a class="el" href="tinycthread_8h.html#a0944e70c2ce4eed616f7bcfd604fba96">thrd_error</a> if the request could not be honored. </dd></dl>

</div>
</div>
<a class="anchor" id="af76e066715b1190d38a69da1c511e30f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int cnd_signal </td>
          <td>(</td>
          <td class="paramtype">cnd_t *&#160;</td>
          <td class="paramname"><em>cond</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Signal a condition variable. </p>
<p>Unblocks one of the threads that are blocked on the given condition variable at the time of the call. If no threads are blocked on the condition variable at the time of the call, the function does nothing and return success. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cond</td><td>A condition variable object. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="tinycthread_8h.html#a6f15c94421801f7f6a4338653b9017dc">thrd_success</a> on success, or <a class="el" href="tinycthread_8h.html#a0944e70c2ce4eed616f7bcfd604fba96">thrd_error</a> if the request could not be honored. </dd></dl>

</div>
</div>
<a class="anchor" id="a2bdc352d949424855c957b0d1916d443"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int cnd_timedwait </td>
          <td>(</td>
          <td class="paramtype">cnd_t *&#160;</td>
          <td class="paramname"><em>cond</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">mtx_t *&#160;</td>
          <td class="paramname"><em>mtx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const struct timespec *&#160;</td>
          <td class="paramname"><em>ts</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Wait for a condition variable to become signaled. </p>
<p>The function atomically unlocks the given mutex and endeavors to block until the given condition variable is signaled by a call to cnd_signal or to cnd_broadcast, or until after the specified time. When the calling thread becomes unblocked it locks the mutex before it returns. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cond</td><td>A condition variable object. </td></tr>
    <tr><td class="paramname">mtx</td><td>A mutex object. </td></tr>
    <tr><td class="paramname">xt</td><td>A point in time at which the request will time out (absolute time). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="tinycthread_8h.html#a6f15c94421801f7f6a4338653b9017dc">thrd_success</a> upon success, or thrd_timeout if the time specified in the call was reached without acquiring the requested resource, or <a class="el" href="tinycthread_8h.html#a0944e70c2ce4eed616f7bcfd604fba96">thrd_error</a> if the request could not be honored. </dd></dl>

</div>
</div>
<a class="anchor" id="ac4dfb82fc3d92bb688cb07308af6a659"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int cnd_wait </td>
          <td>(</td>
          <td class="paramtype">cnd_t *&#160;</td>
          <td class="paramname"><em>cond</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">mtx_t *&#160;</td>
          <td class="paramname"><em>mtx</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Wait for a condition variable to become signaled. </p>
<p>The function atomically unlocks the given mutex and endeavors to block until the given condition variable is signaled by a call to cnd_signal or to cnd_broadcast. When the calling thread becomes unblocked it locks the mutex before it returns. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cond</td><td>A condition variable object. </td></tr>
    <tr><td class="paramname">mtx</td><td>A mutex object. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="tinycthread_8h.html#a6f15c94421801f7f6a4338653b9017dc">thrd_success</a> on success, or <a class="el" href="tinycthread_8h.html#a0944e70c2ce4eed616f7bcfd604fba96">thrd_error</a> if the request could not be honored. </dd></dl>

</div>
</div>
<a class="anchor" id="ae8b3732298d1d316db6438b4c561c0dd"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mtx_destroy </td>
          <td>(</td>
          <td class="paramtype">mtx_t *&#160;</td>
          <td class="paramname"><em>mtx</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Release any resources used by the given mutex. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mtx</td><td>A mutex object. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a89200caf0dc25fcc97df171d0034bff2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int mtx_init </td>
          <td>(</td>
          <td class="paramtype">mtx_t *&#160;</td>
          <td class="paramname"><em>mtx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>type</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a mutex object. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mtx</td><td>A mutex object. </td></tr>
    <tr><td class="paramname">type</td><td>Bit-mask that must have one of the following six values: <ul>
<li><code>mtx_plain</code> for a simple non-recursive mutex </li>
<li><code>mtx_timed</code> for a non-recursive mutex that supports timeout </li>
<li><code>mtx_try</code> for a non-recursive mutex that supports test and return </li>
<li><code>mtx_plain</code> | <code>mtx_recursive</code> (same as <code>mtx_plain</code>, but recursive) </li>
<li><code>mtx_timed</code> | <code>mtx_recursive</code> (same as <code>mtx_timed</code>, but recursive) </li>
<li><code>mtx_try</code> | <code>mtx_recursive</code> (same as <code>mtx_try</code>, but recursive) </li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="tinycthread_8h.html#a6f15c94421801f7f6a4338653b9017dc">thrd_success</a> on success, or <a class="el" href="tinycthread_8h.html#a0944e70c2ce4eed616f7bcfd604fba96">thrd_error</a> if the request could not be honored. </dd></dl>

</div>
</div>
<a class="anchor" id="a8945984db67db8ee774872da64d0e424"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int mtx_lock </td>
          <td>(</td>
          <td class="paramtype">mtx_t *&#160;</td>
          <td class="paramname"><em>mtx</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Lock the given mutex. </p>
<p>Blocks until the given mutex can be locked. If the mutex is non-recursive, and the calling thread already has a lock on the mutex, this call will block forever. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mtx</td><td>A mutex object. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="tinycthread_8h.html#a6f15c94421801f7f6a4338653b9017dc">thrd_success</a> on success, or <a class="el" href="tinycthread_8h.html#a0944e70c2ce4eed616f7bcfd604fba96">thrd_error</a> if the request could not be honored. </dd></dl>

</div>
</div>
<a class="anchor" id="ac577690ddd48f5a1fdf3dc97881a2199"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int mtx_trylock </td>
          <td>(</td>
          <td class="paramtype">mtx_t *&#160;</td>
          <td class="paramname"><em>mtx</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Try to lock the given mutex. </p>
<p>The specified mutex shall support either test and return or timeout. If the mutex is already locked, the function returns without blocking. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mtx</td><td>A mutex object. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="tinycthread_8h.html#a6f15c94421801f7f6a4338653b9017dc">thrd_success</a> on success, or <a class="el" href="tinycthread_8h.html#a3c563aa25920a041d83d4019b113ab5d">thrd_busy</a> if the resource requested is already in use, or <a class="el" href="tinycthread_8h.html#a0944e70c2ce4eed616f7bcfd604fba96">thrd_error</a> if the request could not be honored. </dd></dl>

</div>
</div>
<a class="anchor" id="ae2fb1d2854461fa583017cc9b0bc6cca"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int mtx_unlock </td>
          <td>(</td>
          <td class="paramtype">mtx_t *&#160;</td>
          <td class="paramname"><em>mtx</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Unlock the given mutex. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mtx</td><td>A mutex object. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="tinycthread_8h.html#a6f15c94421801f7f6a4338653b9017dc">thrd_success</a> on success, or <a class="el" href="tinycthread_8h.html#a0944e70c2ce4eed616f7bcfd604fba96">thrd_error</a> if the request could not be honored. </dd></dl>

</div>
</div>
<a class="anchor" id="a1a52b6cd2d15cc6c4741d5124f85d183"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int thrd_create </td>
          <td>(</td>
          <td class="paramtype">thrd_t *&#160;</td>
          <td class="paramname"><em>thr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="tinycthread_8h.html#a7d8f0a9d1b1848b938e49dc7bd97ba07">thrd_start_t</a>&#160;</td>
          <td class="paramname"><em>func</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>arg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a new thread. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">thr</td><td>Identifier of the newly created thread. </td></tr>
    <tr><td class="paramname">func</td><td>A function pointer to the function that will be executed in the new thread. </td></tr>
    <tr><td class="paramname">arg</td><td>An argument to the thread function. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="tinycthread_8h.html#a6f15c94421801f7f6a4338653b9017dc">thrd_success</a> on success, or <a class="el" href="tinycthread_8h.html#ad6010b6ba8c0508cef692f066b09e2ef">thrd_nomem</a> if no memory could be allocated for the thread requested, or <a class="el" href="tinycthread_8h.html#a0944e70c2ce4eed616f7bcfd604fba96">thrd_error</a> if the request could not be honored. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>A thread’s identifier may be reused for a different thread once the original thread has exited and either been detached or joined to another thread. </dd></dl>

</div>
</div>
<a class="anchor" id="ab67b6f182a848d979155d03598325fa7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">thrd_t thrd_current </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Identify the calling thread. </p>
<dl class="section return"><dt>Returns</dt><dd>The identifier of the calling thread. </dd></dl>

</div>
</div>
<a class="anchor" id="ad5380997f9e32a31f802bdd9cb266902"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int thrd_detach </td>
          <td>(</td>
          <td class="paramtype">thrd_t&#160;</td>
          <td class="paramname"><em>thr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Dispose of any resources allocated to the thread when that thread exits. </p>
<dl class="section return"><dt>Returns</dt><dd>thrd_success, or thrd_error on error </dd></dl>

</div>
</div>
<a class="anchor" id="a153e65a389814ce51ad07791e42b2118"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int thrd_equal </td>
          <td>(</td>
          <td class="paramtype">thrd_t&#160;</td>
          <td class="paramname"><em>thr0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">thrd_t&#160;</td>
          <td class="paramname"><em>thr1</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compare two thread identifiers. </p>
<p>The function determines if two thread identifiers refer to the same thread. </p>
<dl class="section return"><dt>Returns</dt><dd>Zero if the two thread identifiers refer to different threads. Otherwise a nonzero value is returned. </dd></dl>

</div>
</div>
<a class="anchor" id="a841a332cdf32140ae6e44a3bb0bcdcd0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void thrd_exit </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>res</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Terminate execution of the calling thread. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">res</td><td>Result code of the calling thread. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aa2e83a544f49f74cf217a69a882b5d80"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int thrd_join </td>
          <td>(</td>
          <td class="paramtype">thrd_t&#160;</td>
          <td class="paramname"><em>thr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>res</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Wait for a thread to terminate. </p>
<p>The function joins the given thread with the current thread by blocking until the other thread has terminated. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">thr</td><td>The thread to join with. </td></tr>
    <tr><td class="paramname">res</td><td>If this pointer is not NULL, the function will store the result code of the given thread in the integer pointed to by <code>res</code>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="tinycthread_8h.html#a6f15c94421801f7f6a4338653b9017dc">thrd_success</a> on success, or <a class="el" href="tinycthread_8h.html#a0944e70c2ce4eed616f7bcfd604fba96">thrd_error</a> if the request could not be honored. </dd></dl>

</div>
</div>
<a class="anchor" id="a77f5f79db415e2363470a8570250f785"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int thrd_sleep </td>
          <td>(</td>
          <td class="paramtype">const struct timespec *&#160;</td>
          <td class="paramname"><em>duration</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct timespec *&#160;</td>
          <td class="paramname"><em>remaining</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Put the calling thread to sleep. </p>
<p>Suspend execution of the calling thread. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">duration</td><td>Interval to sleep for </td></tr>
    <tr><td class="paramname">remaining</td><td>If non-NULL, this parameter will hold the remaining time until time_point upon return. This will typically be zero, but if the thread was woken up by a signal that is not ignored before duration was reached <code>remaining</code> will hold a positive time. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 (zero) on successful sleep, -1 if an interrupt occurred, or a negative value if the operation fails. </dd></dl>

</div>
</div>
<a class="anchor" id="acbfb78346e6b76b23da1d2d8df03549a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void thrd_yield </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Yield execution to another thread. </p>
<p>Permit other threads to run, even if the current thread would ordinarily continue to run. </p>

</div>
</div>
<a class="anchor" id="a286fe7927e9af276a9cfdbc8b9eb08ad"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int tss_create </td>
          <td>(</td>
          <td class="paramtype">tss_t *&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="tinycthread_8h.html#ade88b5efc6801e759cb4be71326a2e2a">tss_dtor_t</a>&#160;</td>
          <td class="paramname"><em>dtor</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a thread-specific storage. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>The unique key identifier that will be set if the function is successful. </td></tr>
    <tr><td class="paramname">dtor</td><td>Destructor function. This can be NULL. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="tinycthread_8h.html#a6f15c94421801f7f6a4338653b9017dc">thrd_success</a> on success, or <a class="el" href="tinycthread_8h.html#a0944e70c2ce4eed616f7bcfd604fba96">thrd_error</a> if the request could not be honored. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>On Windows, the <code>dtor</code> will definitely be called when appropriate for threads created with <a class="el" href="tinycthread_8h.html#a1a52b6cd2d15cc6c4741d5124f85d183">thrd_create</a>. It will be called for other threads in most cases, the possible exception being for DLLs loaded with LoadLibraryEx. In order to be certain, you should use <a class="el" href="tinycthread_8h.html#a1a52b6cd2d15cc6c4741d5124f85d183">thrd_create</a> whenever possible. </dd></dl>

</div>
</div>
<a class="anchor" id="aecebbc66b206171d9381ba94528c6cb7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void tss_delete </td>
          <td>(</td>
          <td class="paramtype">tss_t&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Delete a thread-specific storage. </p>
<p>The function releases any resources used by the given thread-specific storage. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>The key that shall be deleted. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a183e71f731ed566a1d14b056606806f8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void* tss_get </td>
          <td>(</td>
          <td class="paramtype">tss_t&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the value for a thread-specific storage. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>The thread-specific storage identifier. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The value for the current thread held in the given thread-specific storage. </dd></dl>

</div>
</div>
<a class="anchor" id="a608e01c49b84a5ad4f085a9aedc6a680"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int tss_set </td>
          <td>(</td>
          <td class="paramtype">tss_t&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>val</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the value for a thread-specific storage. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>The thread-specific storage identifier. </td></tr>
    <tr><td class="paramname">val</td><td>The value of the thread-specific storage to set for the current thread. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="tinycthread_8h.html#a6f15c94421801f7f6a4338653b9017dc">thrd_success</a> on success, or <a class="el" href="tinycthread_8h.html#a0944e70c2ce4eed616f7bcfd604fba96">thrd_error</a> if the request could not be honored. </dd></dl>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.6
</small></address>
</body>
</html>
